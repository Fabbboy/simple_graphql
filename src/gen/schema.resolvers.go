package gen

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
)

// AddUser is the resolver for the addUser field.
func (r *mutationResolver) AddUser(ctx context.Context, name string) (*User, error) {
	if r.Resolver.Users == nil {
		r.Resolver.Users = make([]*User, 0)
	}

	// check if user already exists
	for _, u := range r.Resolver.Users {
		if u.Name == name {
			return nil, fmt.Errorf("user already exists")
		}
	}

	user := &User{
		ID:   fmt.Sprintf("%d", len(r.Resolver.Users)+1),
		Name: name,
	}

	r.Resolver.Users = append(r.Resolver.Users, user)

	return user, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, userID string, content string) (*Message, error) {
	if r.Resolver.Users == nil {
		r.Resolver.Users = make([]*User, 0)
	}

	if r.Resolver.Messages == nil {
		r.Resolver.Messages = make([]*Message, 0)
	}

	var user *User
	for _, u := range r.Resolver.Users {
		if u.ID == userID {
			user = u
			break
		}
	}

	if user == nil {
		//return error
		return nil, fmt.Errorf("user not found")
	}

	message := &Message{
		ID:      fmt.Sprintf("%d", len(r.Resolver.Messages)+1),
		Content: content,
		User:    user,
	}

	r.Resolver.Messages = append(r.Resolver.Messages, message)

	for _, listener := range r.Resolver.Listeners {
		listener <- message
	}


	return message, nil
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context) ([]*Message, error) {
	if r.Resolver.Messages == nil {
		r.Resolver.Messages = make([]*Message, 0)
	}

	return r.Resolver.Messages, nil
}

// MessageReceived is the resolver for the messageReceived field.
// MessageReceived is the resolver for the messageReceived field.
// MessageReceived is the resolver for the messageReceived field.
func (r *subscriptionResolver) MessageReceived(ctx context.Context) (<-chan *Message, error) {
	if r.Resolver.Listeners == nil {
		r.Resolver.Listeners = make([]chan *Message, 0)
	}

	ch := make(chan *Message)

	r.Resolver.Listeners = append(r.Resolver.Listeners, ch)

	// Clean up the listener when the subscription is terminated
	go func() {
		<-ctx.Done()
		for i, listener := range r.Resolver.Listeners {
			if listener == ch {
				r.Resolver.Listeners = append(r.Resolver.Listeners[:i], r.Resolver.Listeners[i+1:]...)
				close(ch)
				break
			}
		}
	}()

	return ch, nil
}


// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
